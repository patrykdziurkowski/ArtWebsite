@using web.Features.Browse
@using web.Features.Reviews.ReviewArtPiece
@model BrowseModel

@{
    string reviewCooldown = Environment.GetEnvironmentVariable("REVIEW_COOLDOWN_SECONDS")!;
}

<div class="container">
    <div id="selectedTag"></div>
    <div id="artContainer" class="m-auto text-center">
        <h1>Loading...</h1>
    </div>

    <div id="artPieceControls">
        <partial name="../Tags/_TagsPartial" />
        <button id="reviewArt" class="btn btn-secondary m-3" disabled><i class="bi bi-justify-left"></i></button>
        <button  id="skipButton" class="btn btn-warning" @(Model.CurrentReviewerActivePoints < 5 ? "disabled" : "")>
            Skip (<span id="skip-button-points">@Model.CurrentReviewerActivePoints</span> / 5)
        </button>
    </div>
</div>

<div class="modal fade" id="postReviewModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">What next?</h5>
                <button type="button" class="btn-close"></button>
            </div>
            <div class="modal-body"></div>
            <div class="modal-footer">
                <button id="likeArtPiece" class="btn btn-secondary m-3">Like</button>
                <button id="nextArtPiece" class="btn btn-secondary m-3">Next</button>
                <button id="viewArtPiece" class="btn btn-secondary m-3">Details</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="reviewModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Review Art</h5>
                <button type="button" class="btn-close"></button>
            </div>
            <div class="modal-body">
                <form asp-controller="Review" asp-action="ReviewArtPiece" method="post" id="reviewForm">
                    <div class="form-group">
                        <textarea name="comment" class="form-control mb-2" placeholder="Review this art piece" required
                            asp-for="ReviewForm.Comment"></textarea>
                        <span asp-validation-for="ReviewForm.Comment" class="text-danger"></span>
                    </div>
                    <div class="form-group">
                        <div class="rating">
                            <input type="radio" id="star5" name="Rating" asp-for="ReviewForm.Rating" value="5">
                            <label for="star5">&#9733;</label>
                            <input type="radio" id="star4" name="Rating" asp-for="ReviewForm.Rating" value="4">
                            <label for="star4">&#9733;</label>
                            <input type="radio" id="star3" name="Rating" asp-for="ReviewForm.Rating" value="3">
                            <label for="star3">&#9733;</label>
                            <input type="radio" id="star2" name="Rating" asp-for="ReviewForm.Rating" value="2">
                            <label for="star2">&#9733;</label>
                            <input type="radio" id="star1" name="Rating" asp-for="ReviewForm.Rating" value="1">
                            <label for="star1">&#9733;</label>
                        </div>
                        <span asp-validation-for="ReviewForm.Rating" class="text-danger"></span>
                    </div>
                    <div class="form-group">
                        <input type="hidden" name="artPieceId" value="">
                    </div>
                    <button type="submit" class="btn btn-primary">Submit Review</button>
                </form>
            </div>
        </div>
    </div>
</div>

<partial name="../ArtPieces/_ArtPieceDetailsModalPartial" />

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const params = new URLSearchParams(window.location.search);
            const tagParameter = params.get('tag');
            document.querySelector('#selectedTag').innerText = tagParameter;

            let artPieceTags = null;
            let artPieceId;
            let artPieceDetails = null;
            let reviewTimeout = null;
            let isLiked = false;
            let currentPoints = @Model.CurrentReviewerActivePoints;
            let artPiece = await loadArtPiece();

            if (artPiece === null) return;

            artPieceId = artPiece.id.value;

            const likeButton = document.querySelector('#likeArtPiece');
            const reviewForm = document.querySelector('#reviewForm');
            const reviewModal = new bootstrap.Modal(document.querySelector('#reviewModal'));
            const postReviewModal = new bootstrap.Modal(document.querySelector('#postReviewModal'));

            // note: this is registered here via event listener instead of using boostrap's data tags
            // because of issues when using both data-bs-dismiss alongside new bootstrap.Modal(...)
            document.querySelector('#reviewModal .btn-close').addEventListener('click', () => {
                reviewModal.hide();
            });
            document.querySelector('#postReviewModal .btn-close').addEventListener('click', () => {
                postReviewModal.hide();
            });

            async function nextArtPiece() {
                postReviewModal.hide();
                artPieceDetails.hide();
                await loadArtPiece();
            }

            function showDetails() {
                postReviewModal.hide();
                artPieceDetails.show();
            }

            function artPieceReviewed() {
                reviewModal.hide();
                postReviewModal.show();

                artPieceDetails = new ArtPieceDetails(artPieceId);
                artPieceDetails.onBack = () => {
                    postReviewModal.show();
                };
                artPieceDetails.onHidden = async () => {
                    if (!postReviewModal._element.classList.contains('show')) {
                        await loadArtPiece();
                    }
                };

                postReviewModal._element.addEventListener('hidden.bs.modal', async () => {
                    if (!artPieceDetails.isShown) {
                        await loadArtPiece();
                    }
                });
            }

            function disableReviewingUntilReady() {
                const button = document.getElementById('reviewArt');
                if (reviewTimeout !== null) {
                    clearTimeout(reviewTimeout);
                }

                button.setAttribute('disabled', 'disabled');

                reviewTimeout = setTimeout(() => {
                    button.removeAttribute('disabled');
                }, Number(@reviewCooldown) * 1000);
            }

            async function loadArtPiece() {
                const urlParams = new URLSearchParams(window.location.search);
                const tagParam = urlParams.get('tag');
                const url = (tagParam === null) ? '/api/artpiece' : `/api/artpiece?tag=${encodeURIComponent(tagParam)}`;
                const response = await fetch(url);
                const artContainer = document.getElementById('artContainer');
                
                if (response.status === 204) {
                    artContainer.textContent = '';
                    const noImagesH1 = document.createElement('h1');
                    noImagesH1.textContent = 'No more images to review.';
                    artContainer.appendChild(noImagesH1);
                    document.querySelector('#artPieceControls').style.display = 'none';
                    return null;
                }
                
                const data = await response.json();
                
                if (!data || !data.imagePath) {
                    artContainer.textContent = '';
                    const noImagesH1 = document.createElement('h1');
                    noImagesH1.textContent = 'No more images to review.';
                    artContainer.appendChild(noImagesH1);
                    document.querySelector('#artPieceControls').style.display = 'none';
                    return null;
                }
                
                artContainer.textContent = '';
                
                const img = document.createElement('img');
                img.id = 'artPieceImage';
                img.src = data.imagePath;
                img.alt = 'Art Piece';
                img.className = 'img-fluid rounded';
                artContainer.appendChild(img);
                
                const descriptionDiv = document.createElement('div');
                descriptionDiv.className = 'p-2';
                const descriptionP = document.createElement('p');
                descriptionP.textContent = data.description;
                descriptionDiv.appendChild(descriptionP);
                artContainer.appendChild(descriptionDiv);
                
                document.querySelector('#reviewForm input[name="artPieceId"]').value = data.id.value;
                artPieceId = data.id.value;
                artPieceTags = new Tags(artPieceId, document.querySelector('#artPieceControls .art-piece-tags'));
                disableReviewingUntilReady();
                return data;
            }

            async function like(e) {
                const artPieceId = document.querySelector('#reviewForm input[name="artPieceId"]').value;

                if (isLiked) {
                    const response = await fetch(`/api/artpieces/${artPieceId}/like`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });

                    if (!response.ok) {
                        console.error('Failed to unlike the art piece', response.statusText);
                        return;
                    }

                    likeButton.innerText = "Like";
                    isLiked = false;
                } else {
                    const response = await fetch(`/api/artpieces/${artPieceId}/like`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });

                    if (!response.ok) {
                        console.error('Failed to like the art piece', response.statusText);
                        return;
                    }

                    likeButton.innerText = "Unlike";
                    isLiked = true;
                }
            }

            async function review(e) {
                e.preventDefault();
                const form = new FormData(e.target);

                const data = {
                    comment: form.get('comment'),
                    rating: document.querySelector('input[name="Rating"]:checked').value,
                    artPieceId: form.get('artPieceId')
                };

                const response = await fetch('/api/reviews/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });

                if (response.status !== 200) {
                    const data = await response.json();
                    const validationErrorsText = document.querySelector('#reviewForm *[name="comment"] + span');
                    validationErrorsText.innerText = data.errors.Comment;
                    return;
                }

                currentPoints += 10;
                document.querySelector('#skip-button-points').innerText = currentPoints;
                document.querySelector('#skipButton').disabled = currentPoints < 5;
                artPieceReviewed();
            }

            document.getElementById('skipButton').addEventListener('click', async function() {
                const button = this;
                button.disabled = true;
                
                try {
                    const response = await fetch('/api/artpieces/current', {
                        method: 'DELETE',
                    });
                    
                    if (!response.ok) {
                        const data = await response.json();
                        alert('Failed to skip: ' + (data.errors?.[0]?.message || 'Unknown error'));
                        
                        return;
                    }

                    currentPoints -= 5;
                    document.getElementById('reviewArt').removeAttribute('disabled', 'disabled');
                    await loadArtPiece();
                } catch (error) {
                    console.error('Error:', error);
                    alert('An error occurred while skipping');
                }

                document.querySelector('#skip-button-points').innerText = currentPoints;
                document.querySelector('#skipButton').disabled = currentPoints < 5;
            });

            likeButton.addEventListener('click', like);
            reviewForm.addEventListener('submit', review);
            document.querySelector('#reviewArt').addEventListener('click', () => {
                reviewModal.show();
            });

            document.querySelector('#nextArtPiece').addEventListener('click', nextArtPiece);
            document.querySelector('#viewArtPiece').addEventListener('click', showDetails);

            document.documentElement.style.setProperty('--review-cooldown', '@reviewCooldown' + 's');
        });
    </script>
}